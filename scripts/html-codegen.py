#!/usr/bin/env python

if __name__ != "__main__":
    return

from contextlib import contextmanager
from dataclasses import dataclass
from re import sub
from typing import Optional

import pandas as pd
from requests import head

MDN = "https://developer.mozilla.org"
MDN_ELEMENTS = f"{MDN}/en-US/docs/Web/HTML/Element"
MDN_ATTRIBUTES = f"{MDN}/en-US/docs/Web/HTML/Attributes"

HEADER = f"""// Programmatically generated by scripts/codegen.py, do not edit manually.
//! HTML elements and attributes definitions.
//! 
//! In the Wasmadeus framework, [HTML elements]({MDN_ELEMENTS}) are replaced
//! with simple rust functions taking one or more [`Attributes`]
//! for input and yielding a [`Component`].
//! 
//! [HTML attributes]({MDN_ATTRIBUTES}) are simply rust structs that implement 
//! the [`Attribute`] trait.
//!
//! This module contains the definitions and documentation of all standard HTML 
//! elements and attributes, including the deprecated and experimental ones.

use crate::attribute::attributes;
use crate::component::elements;

"""

ATTRIBUTE_RENAME_OVERRIDE = {
    "accept-charset": "AcceptCharset",
    "accesskey": "AccessKey",
    "autocapitalize": "AutoCapitalize",
    "autocomplete": "AutoComplete",
    "autofocus": "AutoFocus",
    "autoplay": "AutoPlay",
    "bgcolor": "BgColor",
    "contenteditable": "ContentEditable",
    "contextmenu": "ContextMenu",
    "crossorigin": "CrossOrigin",
    "datetime": "DateTime",
    "dirname": "DirName",
    "enctype": "EncType",
    "enterkeyhint": "EnterKeyHint",
    "formaction": "FormAction",
    "formenctype": "FormEnctype",
    "formmethod": "FormMethod",
    "formnovalidate": "FormNoValidate",
    "formtarget": "FormTarget",
    "hreflang": "HrefLang",
    "http-equiv": "HttpEquiv",
    "intrinsicsize": "IntrinsicSize",
    "inputmode": "InputMode",
    "ismap": "IsMap",
    "itemprop": "ItemProp",
    "maxlength": "MaxLength",
    "minlength": "MinLength",
    "novalidate": "NoValidate",
    "placeholder": "PlaceHolder",
    "playsinline": "PlaysInline",
    "readonly": "ReadOnly",
    "referrerpolicy": "ReferrerPolicy",
    "rowspan": "RowSpan",
    "sandbox": "SandBox",
    "spellcheck": "SpellCheck",
    "srcdoc": "SrcDoc",
    "srclang": "SrcLang",
    "srcset": "SrcSet",
    "tabindex": "TabIndex",
    "usemap": "UseMap",
    "value": "DefaultValue",
}

def format_link(mdn_route: Optional[str]) -> str:
    return "PLACEHOLDER LINK"
    MISSING = "*Missing MDN documentation.*"

    if mdn_route is None:
        return MISSING

    full_link = f"{MDN}{mdn_route}"
    res = head(full_link)

    if res.status_code == 200:
        return f"[MDN documentation.]({full_link})"
    else:
        return MISSING

@dataclass
class Element:
    name: str
    desc: str
    deprecated: bool
    mdn_link: str
    rust_name: str
    rust_link: str
    possible_attributes: list[str]

elements = {}

def make_element(name, mdn_route, desc, deprecated):
    link = format_link(mdn_route)
    rust_name = name[1:-1]
    rust_link = f"[`{rust_name}`]"

    global elements
    elements[name] = Element(
        name,
        desc,
        deprecated,
        link,
        rust_name,
        rust_link,
        [],
    )

def extract_element(row, deprecated):
    (name, mdn_route), (desc, _) = row

    if name.startswith("<h1>"):
        for i, name in enumerate(name.split(", ")):
            desc = f"Represents a section heading of level {i + 1}. <h1> being the highest and <h6> the lowest."
            make_element(name, mdn_route, desc, deprecated)
    else:
        make_element(name, mdn_route, desc, deprecated)

tables = pd.read_html(MDN_ELEMENTS, extract_links="all")
for table in tables[:-1]:
    table.apply(extract_element, axis="columns", deprecated=False)
tables[-1].apply(extract_element, axis="columns", deprecated=True)

@dataclass
class Attribute:
    name: str
    desc: str
    deprecated: bool
    mdn_link: str
    rust_name: str
    rust_link: str
    possible_elements: Optional[list[str]]
    content_editable: bool

attributes = {}

def extract_attribute(row):
    (name, mdn_route), (elements, _), (desc, _) = row

    name, *warnings = name.replace("  ", " ").split(" ")
    deprecated = any([warning.lower() == "deprecated" for warning in warnings])

    if name == "data-*":
        return

    link = format_link(mdn_route)

    if elements == "Global attribute":
        elements = None
    else:
        elements = list(elements.replace("  ", " ").split(", "))

    content_editable = elements is not None and "contenteditable" in elements
    if content_editable:
        elements.remove("contenteditable")

    if (override := ATTRIBUTE_RENAME_OVERRIDE.get(name)) is not None:
        rust_name = override
    else:
        rust_name = name[0].upper() + name[1:]

    rust_link = f"[`{rust_name}`]"

    desc = desc.replace("  ", " ")

    global attributes
    attributes[name] = Attribute(
        name,
        desc,
        deprecated,
        link,
        rust_name,
        rust_link,
        elements,
        content_editable,
    )

tables = pd.read_html(MDN_ATTRIBUTES, extract_links="all")
tables[0].apply(extract_attribute, axis="columns")

# Make elements link to attributes.
for attr in attributes.values():
    if attr.possible_elements is None:
        # Can be applied to any element.
        for elem in elements.values():
            elem.possible_attributes.append(attr.name)
    else:
        # Can be applied to specific elements.
        for elem_name in attr.possible_elements:
            elements[elem_name].possible_attributes.append(attr.name)

# Sort possible elements and attributes alphabetically.
for attr in attributes.values():
    if attr.possible_elements is not None:
        attr.possible_elements.sort()
for elem in elements.values():
    elem.possible_attributes.sort()

# Replace elements name by their rust links.
IN_ANGLED_BRACKETS = r"<(.+?)>"
for dic in [attributes, elements]:
    for obj in dic.values():
        obj.desc = obj.desc.replace("<link rel=\"manifest\"> ", "")
        obj.desc = sub(IN_ANGLED_BRACKETS, lambda x: f"{elements[x.group()].rust_link}", obj.desc)

# Sort attributes and elements by name.
key = lambda x: x.rust_name
attributes = sorted(attributes.values(), key=key)
elements = sorted(elements.values(), key=key)

# for attr in attributes:
#     print(attr)
# for elem in elements:
#     print(elem)

# Opens a rust macro call.
@contextmanager
def macro_call(macro_name: str):
    print(macro_name + "! {")
    yield
    print("}")

print(HEADER)
with macro_call("attributes"):
    pass # TODO
print()
with macro_call("elements"):
    pass # TODO